# DataBase

## 原理

### 数据库范式

#### 第一范式

数据表中的每一列(字段)，必须是不可拆分的最小单元，也就是确保每一列的原子性。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。

#### 第二范式

两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。

#### 第三范式

满足2NF后，要求：表中的每一列都要与主键直接相关，而不是间接相关（表中的每一列只能依赖于主键）。数据不能存在传递关系，即没个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的

## Mysql

#### mysql索引类型（深度赋智）

##### 聚集索引和非聚集索引（二级索引）

- 块按照主键顺序存放
- 块可能分散，mysql中存储的指向数据的索引

#### mysql Join

Mysql只支持Nested Loop Join，不支持其他数据库提供的Hash Join & sort- Merge Join

因此，在多表进行Join的过程中，对于被驱动表的Join的列建立索引可以有效的优化开销 

#### mysql 如何存储数据

#### mysql事务

**[mysql事务隔离级别和实现原理](https://zhuanlan.zhihu.com/p/117476959)**

##### **基本概念**

**脏读**

脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。

**可重复读**

可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据**更新（UPDATE）**操作。

**不可重复读**

对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据**更新（UPDATE）**操作。

**幻读**

幻读是针对数据**插入（INSERT）**操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。

##### **事务隔离级别**

SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：

1. 读未提交（READ UNCOMMITTED）
2. 读提交 （READ COMMITTED）
3. 可重复读 （REPEATABLE READ）
4. 串行化 （SERIALIZABLE）

从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，**可重复读**是 MySQL 的默认级别。

事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。

![img](../part-time Job/img/v2-2e1a7203478165890e2d09f36cb39857_1440w.png)

只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都有缺陷。

#### ACID

##### 原子性

事务要么全部执行，要么全部不执行

实现：通过undo log来实现事务的原子性

##### 持久性

事务一旦提交，数据一定会被写入到数据库并持久的存储下来

通过redo log 来实现

![image-20210411145824647](/Users/xingzheng/Note/part-time Job/img/image-20210411145824647.png)

## redis

### 基本数据结构及实现

### redis key很多

### 和memcache的区别



## MemCache

## 面经

### mysql

#### mysql的索引有哪些

#### 乐观锁悲观锁

#### 事务的ACID及实现

#### mysql慢查询及其优化

